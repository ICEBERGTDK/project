-rm
-clear
getwd()
rm(list=ls())
maxInf <- infPSParams$maxInf
SEIR <- function(S0, E0, I0, N, tau,
beta, X, rateE,
infPeriodSpec = c('exp', 'PS', 'IDD'),
infExpParams = NULL,
infPSParams = NULL,
infIDDParams = NULL) {
infPeriodSpec <- match.arg(infPeriodSpec, c('exp', 'PS', 'IDD'))
infPeriodSpec <- match.arg(infPeriodSpec, c('exp', 'PS', 'IDD'))
# check for valid initial values
if (S0 + E0 + I0 > N) stop("N must be larger than the sum of the initial compartment values")
if (S0 < 0 | E0 < 0 | I0 < 0 | N < 1 | tau < 1) {
stop("invalid epidemic specifications (check that S0, E0, I0, N, tau >= 0)")
}
if (rateE < 0) stop("rateE must be positive")
# check that beta and X are valid
# must be matrix (later check that beta inits are same length as ncol(X))
if(!is.matrix(X)) {
stop('X must be a matrix')
}
# must have one row for each time point
if (nrow(X) != tau) {
stop('X must have rows for each time point (nrow(X) should = tau)')
}
if (ncol(X) != length(beta)) {
stop('Value for beta must be correct length (one element for each column of X)')
}
if (infPeriodSpec == 'exp') {
if (is.null(infExpParams)) stop('infExpParams must be specified')
if (!is.list(infExpParams)) {
stop('infExpParams must be a list')
}
if (!all(names(infExpParams) %in% c('rateI'))) {
stop("if infPeriodSpec = 'exp', infExpParams must contain 'rateI'")
}
rateI <- infExpParams$rateI
if (rateI < 0) stop("rateI must be positive")
simExp(S0, E0, I0, N, tau, beta, X, rateE, rateI)
} else if (infPeriodSpec == 'PS') {
if (is.null(infPSParams)) stop('infPSParams must be specified')
if (!is.list(infPSParams)) {
stop('infPSParams must be a list')
}
if (!all(names(infPSParams) %in% c('dist', 'psParams', 'maxInf'))) {
stop("if infPeriodSpec = 'PS', infPSParams must contain 'dist', 'psParams', 'maxInf'")
}
dist <- match.arg(infPSParams$dist, c('exp', 'gamma', 'weibull'))
psParams <- infPSParams$psParams
maxInf <- infPSParams$maxInf
psParams <- psParamsCheck(psParams, dist)
if (maxInf < 1) stop('maxInf must be >= 1')
simPS(S0, E0, I0, N, tau,
beta, X, rateE,
dist, psParams, maxInf)
} else if (infPeriodSpec == 'IDD') {
if (is.null(infIDDParams)) stop('infIDDParams must be specified')
if (!is.list(infIDDParams)) {
stop('infIDDParams must be a list')
}
if (!all(names(infIDDParams) %in% c('iddFun', 'iddParams', 'maxInf'))) {
stop("if infPeriodSpec = 'IDD', infIDDParams must contain 'iddFun', 'iddParams', 'maxInf'")
}
iddFun <- infIDDParams$iddFun
iddParams <- infIDDParams$iddParams
maxInf <- infIDDParams$maxInf
# if spline model, need to fix the XBasis argument and remove it from the parameters
if (!is.character(all.equal(iddFun, splineIDD))) {
XBasis <- iddParams$XBasis
iddParams <- iddParams[-which(names(iddParams) == 'XBasis')]
iddFun <- fixFunArgs(substitute(splineIDD(XBasis=XBasis)))
}
if (maxInf < 1) stop('maxInf must be >= 1')
IDDCurve <- do.call(iddFun, args = list(x = 1:maxInf,
params = iddParams))
simIDD(S0, E0, I0, N, tau,
beta, X, rateE,
IDDCurve, maxInf)
}
#'
#' # plot incidence curve
#' plot(datIDD$Istar, type = 'l', main = 'Incidence', xlab = 'Epidemic Time',
#'      ylab = 'Count')
#'
#' @references Porter, Aaron T., and Oleson, Jacob J. "A path-specific SEIR model
#'  for use with general latent and infectious time distributions." \emph{Biometrics}
#'   69.1 (2013): 101-108.
#'
#' @export
SEIR <- function(S0, E0, I0, N, tau,
beta, X, rateE,
infPeriodSpec = c('exp', 'PS', 'IDD'),
infExpParams = NULL,
infPSParams = NULL,
infIDDParams = NULL) {
infPeriodSpec <- match.arg(infPeriodSpec, c('exp', 'PS', 'IDD'))
# check for valid initial values
if (S0 + E0 + I0 > N) stop("N must be larger than the sum of the initial compartment values")
if (S0 < 0 | E0 < 0 | I0 < 0 | N < 1 | tau < 1) {
stop("invalid epidemic specifications (check that S0, E0, I0, N, tau >= 0)")
}
if (rateE < 0) stop("rateE must be positive")
# check that beta and X are valid
# must be matrix (later check that beta inits are same length as ncol(X))
if(!is.matrix(X)) {
stop('X must be a matrix')
}
# must have one row for each time point
if (nrow(X) != tau) {
stop('X must have rows for each time point (nrow(X) should = tau)')
}
if (ncol(X) != length(beta)) {
stop('Value for beta must be correct length (one element for each column of X)')
}
if (infPeriodSpec == 'exp') {
if (is.null(infExpParams)) stop('infExpParams must be specified')
if (!is.list(infExpParams)) {
stop('infExpParams must be a list')
}
if (!all(names(infExpParams) %in% c('rateI'))) {
stop("if infPeriodSpec = 'exp', infExpParams must contain 'rateI'")
}
rateI <- infExpParams$rateI
if (rateI < 0) stop("rateI must be positive")
simExp(S0, E0, I0, N, tau, beta, X, rateE, rateI)
} else if (infPeriodSpec == 'PS') {
if (is.null(infPSParams)) stop('infPSParams must be specified')
if (!is.list(infPSParams)) {
stop('infPSParams must be a list')
}
if (!all(names(infPSParams) %in% c('dist', 'psParams', 'maxInf'))) {
stop("if infPeriodSpec = 'PS', infPSParams must contain 'dist', 'psParams', 'maxInf'")
}
dist <- match.arg(infPSParams$dist, c('exp', 'gamma', 'weibull'))
psParams <- infPSParams$psParams
maxInf <- infPSParams$maxInf
psParams <- psParamsCheck(psParams, dist)
if (maxInf < 1) stop('maxInf must be >= 1')
simPS(S0, E0, I0, N, tau,
beta, X, rateE,
dist, psParams, maxInf)
} else if (infPeriodSpec == 'IDD') {
if (is.null(infIDDParams)) stop('infIDDParams must be specified')
if (!is.list(infIDDParams)) {
stop('infIDDParams must be a list')
}
if (!all(names(infIDDParams) %in% c('iddFun', 'iddParams', 'maxInf'))) {
stop("if infPeriodSpec = 'IDD', infIDDParams must contain 'iddFun', 'iddParams', 'maxInf'")
}
iddFun <- infIDDParams$iddFun
iddParams <- infIDDParams$iddParams
maxInf <- infIDDParams$maxInf
# if spline model, need to fix the XBasis argument and remove it from the parameters
if (!is.character(all.equal(iddFun, splineIDD))) {
XBasis <- iddParams$XBasis
iddParams <- iddParams[-which(names(iddParams) == 'XBasis')]
iddFun <- fixFunArgs(substitute(splineIDD(XBasis=XBasis)))
}
if (maxInf < 1) stop('maxInf must be >= 1')
IDDCurve <- do.call(iddFun, args = list(x = 1:maxInf,
params = iddParams))
simIDD(S0, E0, I0, N, tau,
beta, X, rateE,
IDDCurve, maxInf)
}
}
ls()
dist <- match.arg(infPSParams$dist, c('exp', 'gamma', 'weibull'))
#'
#' # plot incidence curve
#' plot(datIDD$Istar, type = 'l', main = 'Incidence', xlab = 'Epidemic Time',
#'      ylab = 'Count')
#'
#' @references Porter, Aaron T., and Oleson, Jacob J. "A path-specific SEIR model
#'  for use with general latent and infectious time distributions." \emph{Biometrics}
#'   69.1 (2013): 101-108.
#'
#' @export
SEIR <- function(S0, E0, I0, N, tau,
beta, X, rateE,
infPeriodSpec = c('exp', 'PS', 'IDD'),
infExpParams = NULL,
infPSParams = NULL,
infIDDParams = NULL) {
infPeriodSpec <- match.arg(infPeriodSpec, c('exp', 'PS', 'IDD'))
# check for valid initial values
if (S0 + E0 + I0 > N) stop("N must be larger than the sum of the initial compartment values")
if (S0 < 0 | E0 < 0 | I0 < 0 | N < 1 | tau < 1) {
stop("invalid epidemic specifications (check that S0, E0, I0, N, tau >= 0)")
}
if (rateE < 0) stop("rateE must be positive")
# check that beta and X are valid
# must be matrix (later check that beta inits are same length as ncol(X))
if(!is.matrix(X)) {
stop('X must be a matrix')
}
# must have one row for each time point
if (nrow(X) != tau) {
stop('X must have rows for each time point (nrow(X) should = tau)')
}
if (ncol(X) != length(beta)) {
stop('Value for beta must be correct length (one element for each column of X)')
}
if (infPeriodSpec == 'exp') {
if (is.null(infExpParams)) stop('infExpParams must be specified')
if (!is.list(infExpParams)) {
stop('infExpParams must be a list')
}
if (!all(names(infExpParams) %in% c('rateI'))) {
stop("if infPeriodSpec = 'exp', infExpParams must contain 'rateI'")
}
rateI <- infExpParams$rateI
if (rateI < 0) stop("rateI must be positive")
simExp(S0, E0, I0, N, tau, beta, X, rateE, rateI)
} else if (infPeriodSpec == 'PS') {
if (is.null(infPSParams)) stop('infPSParams must be specified')
if (!is.list(infPSParams)) {
stop('infPSParams must be a list')
}
if (!all(names(infPSParams) %in% c('dist', 'psParams', 'maxInf'))) {
stop("if infPeriodSpec = 'PS', infPSParams must contain 'dist', 'psParams', 'maxInf'")
}
dist <- match.arg(infPSParams$dist, c('exp', 'gamma', 'weibull'))
psParams <- infPSParams$psParams
maxInf <- infPSParams$maxInf
psParams <- psParamsCheck(psParams, dist)
if (maxInf < 1) stop('maxInf must be >= 1')
simPS(S0, E0, I0, N, tau,
beta, X, rateE,
dist, psParams, maxInf)
} else if (infPeriodSpec == 'IDD') {
if (is.null(infIDDParams)) stop('infIDDParams must be specified')
if (!is.list(infIDDParams)) {
stop('infIDDParams must be a list')
}
if (!all(names(infIDDParams) %in% c('iddFun', 'iddParams', 'maxInf'))) {
stop("if infPeriodSpec = 'IDD', infIDDParams must contain 'iddFun', 'iddParams', 'maxInf'")
}
iddFun <- infIDDParams$iddFun
iddParams <- infIDDParams$iddParams
maxInf <- infIDDParams$maxInf
# if spline model, need to fix the XBasis argument and remove it from the parameters
if (!is.character(all.equal(iddFun, splineIDD))) {
XBasis <- iddParams$XBasis
iddParams <- iddParams[-which(names(iddParams) == 'XBasis')]
iddFun <- fixFunArgs(substitute(splineIDD(XBasis=XBasis)))
}
if (maxInf < 1) stop('maxInf must be >= 1')
IDDCurve <- do.call(iddFun, args = list(x = 1:maxInf,
params = iddParams))
simIDD(S0, E0, I0, N, tau,
beta, X, rateE,
IDDCurve, maxInf)
}
}
View(SEIR)
View(SEIR)
View(SEIR)
View(SEIR)
